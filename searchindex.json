{"categories":[],"posts":[{"content":"一、XML简介 什么是XML xml 是可扩展的标记性语言。\nXML的作用  用来保存数据，而且这些数据具有自我描述性； 它还可以作为项目或者模块的配置文件； 还可以作为网络传输数据的格式（现在JSON 为主）。  XML的语法 1.文档声明 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot; ?\u0026gt; \u0026lt;!--以上内容就是xml文件的声明 这个\u0026lt;?xml 要连在一起写，否则会有报错 version=\u0026quot;1.0\u0026quot; 表示xml的版本 encoding=\u0026quot;utf-8\u0026quot;表示xml文件本身的编码 standalone=\u0026quot;yes/no\u0026quot;表示这个xml文件是否是独立的xml文件 --\u0026gt; \u0026lt;books\u0026gt;\u0026lt;!--books表示多个图书信息--\u0026gt; \u0026lt;book sn=\u0026quot;SN1q243143235\u0026quot;\u0026gt;\u0026lt;!--book表示一个图书信息，sn表示图书的序列号--\u0026gt; \u0026lt;name\u0026gt;时间简史\u0026lt;/name\u0026gt;\u0026lt;!--name表示书名--\u0026gt; \u0026lt;author\u0026gt;霍金\u0026lt;/author\u0026gt;\u0026lt;!--author表示作者--\u0026gt; \u0026lt;price\u0026gt;75\u0026lt;/price\u0026gt;\u0026lt;!--price表示金额--\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;book sn=\u0026quot;SN1q243143235\u0026quot;\u0026gt;\u0026lt;!--book表示一个图书信息，sn表示图书的序列号--\u0026gt; \u0026lt;name\u0026gt;Java\u0026lt;/name\u0026gt;\u0026lt;!--name表示书名--\u0026gt; \u0026lt;author\u0026gt;沙老师\u0026lt;/author\u0026gt;\u0026lt;!--author表示作者--\u0026gt; \u0026lt;price\u0026gt;9.9\u0026lt;/price\u0026gt;\u0026lt;!--price表示金额--\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;/books\u0026gt;  2.元素（标签）   html 标签： 格式：\u0026lt;标签名\u0026gt;封装的数据\u0026lt;/标签名\u0026gt; 单标签：\u0026lt;标签名/\u0026gt; \u0026lt;br /\u0026gt; 换行\u0026lt;hr /\u0026gt;水平线 双标签：\u0026lt;标签名\u0026gt;封装的数据\u0026lt;/标签名\u0026gt; 标签名大小写不敏感 标签有属性，有基本属性和事件属性 标签要闭合（不闭合，html 中不报错。但我们要养成良好的书写习惯，最好闭合）\n  xml元素：\nXML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。\n元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。\n\u0026lt;bookstore\u0026gt; \u0026lt;book category=\u0026quot;CHILDREN\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Harry Potter\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt;J K. Rowling\u0026lt;/author\u0026gt; \u0026lt;year\u0026gt;2005\u0026lt;/year\u0026gt; \u0026lt;price\u0026gt;29.99\u0026lt;/price\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;book category=\u0026quot;WEB\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Learning XML\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt;Erik T. Ray\u0026lt;/author\u0026gt; \u0026lt;year\u0026gt;2003\u0026lt;/year\u0026gt; \u0026lt;price\u0026gt;39.95\u0026lt;/price\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;/bookstore\u0026gt;  在上例中，\n\u0026lt;bookstore\u0026gt; 和 \u0026lt;book\u0026gt; 都拥有元素内容，因为它们包含了其他元素；\n\u0026lt;author\u0026gt; 只有文本内容，因为它仅包含文本；\n只有\u0026lt;book\u0026gt; 元素拥有属性 (category=\u0026quot;CHILDREN\u0026rdquo;)。\n  XML 命名规则：\n 名称可以含字母、数字以及其他的字符； 名称不能以数字或者标点符号开始； 名称不能以字符“xml”（或者XML、Xml）开始（它是可以的）； 名称不能包含空格；    xml 中的元素（标签）也分成单标签和双标签：\n\u0026lt;book category=\u0026quot;WEB\u0026quot; title=\u0026quot;Learning XML\u0026quot; author=\u0026quot;Erik T. Ray\u0026quot; year=\u0026quot;2003\u0026quot; price=\u0026quot;39.95\u0026quot;/\u0026gt;    3. xml 属性 xml 的标签属性和html 的标签属性是非常类似的，属性可以提供元素的额外信息。 一个标签上可以书写多个属性，每个属性的值必须使用引号引起来。 它的规则和标签的书写规则一致。\n4.语法规则   所有XML 元素都须有关闭标签（也就是闭合）\n  XML 标签对大小写敏感\n  XML 必须正确地嵌套\n  XML 文档必须有根元素，根元素就是顶级元素，没有父标签的元素叫顶级元素，因此，根元素就是没有父标签的顶级元素，而且是唯一一个才行。\n  XML 中的特殊字符\n要写\u0026lt;，则写成\u0026amp;lt;要写\u0026gt;，则写成\u0026amp;gt;\n  **文本区域（CDATA 区）**当有大量文字字符要展示时使用\nCDATA 语法可以告诉xml 解析器，CDATA 里的文本内容，只是纯文本，不需要xml 语法解析 CDATA 格式：\u0026lt;![CDATA[ 这里可以把你输入的字符原样显示，不会解析xml ]]\u0026gt;\n   二、XML解析技术介绍 xml 为可扩展的标记语言，不管是html 文件还是xml 文件，它们都是标记型文档，都可以使用w3c 组织制定的dom 技术来解析。\ndocument 对象表示的是整个文档（可以是html 文档，也可以是xml 文档）。\n早期JDK 为我们提供了两种xml 解析技术DOM 和Sax 简介（已经过时，但我们需要知道这两种技术）DOm解析技术是W3C 组织制定的，而所有的编程语言都对这个解析技术使用了自己语言的特点进行实现，Java 对DOM技术解析标记也做了实现。\nsun 公司在JDK5 版本对DOM解析技术进行升级：SAX（ Simple API for XML ）\nSAX 解析，它跟W3C 制定的解析不太一样，它是以类似事件机制通过回调告诉用户当前正在解析的内容。\n它是一行一行，地读取xml 文件进行解析的，不会创建大量的dom 对象。所以，它在解析xml 时，在内存的使用上和性能上都优于Dom 解析。\n第三方的解析：\njdom 在dom 基础上进行了封装；\ndom4j 又对jdom 进行了封装；\npull 主要用在Android 手机开发，是在跟sax 非常类似都是事件机制解析xml 文件。\n这个Dom4j 它是第三方的解析技术。我们需要使用第三方给我们提供好的类库才可以解析xml 文件。\nDom4j解析技术（重点） 由于dom4j 它不是sun 公司的技术，而属于第三方公司的技术，我们需要使用dom4j 就需要到dom4j 官网下载dom4j的jar 包。\nDom4j下载下来为一个zip压缩包，解压后，docs为第三方类的学习文档，打开后，点击index.html文件，选择左侧栏的Quick Start可以看到快速入门的学习教程；lib目录是dom4j需要依赖其他第三方的类库；src为第三方类库的源代码目录。\ndom4j的编程步骤 第一步： 先加载xml 文件，创建Document 对象 第二步：通过Document 对象拿到根元素对象 第三步：通过根元素.elelemts(标签名); 可以返回一个集合，这个集合里放着所有你指定的标签名的元素对象 第四步：找到你想要修改、删除的子元素，进行相应的操作 第五步，保存到硬盘上\n**注意：**在项目中创建一个lib目录，找到dom4j的压缩包中的dom4j-1.6.1.jar包，将这个jar放入lib目录中，并右击Add as Library，添加到类路径。添加到类路径后，jar包前面会出现一个可以展开的小三角形，里面会生成一些内容。\n需要解析的books.xml 文件内容为：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;books\u0026gt; \u0026lt;book sn=\u0026quot;SN12341232\u0026quot;\u0026gt; \u0026lt;name\u0026gt;辟邪剑谱\u0026lt;/name\u0026gt; \u0026lt;price\u0026gt;9.9\u0026lt;/price\u0026gt; \u0026lt;author\u0026gt;班主任\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;book sn=\u0026quot;SN12341231\u0026quot;\u0026gt; \u0026lt;name\u0026gt;葵花宝典\u0026lt;/name\u0026gt; \u0026lt;price\u0026gt;99.99\u0026lt;/price\u0026gt; \u0026lt;author\u0026gt;班长\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;/books\u0026gt;  Dom4jTest.java为：\n@Test public void readXML() throws Exception { // 需要分四步操作: // 第一步，通过创建SAXReader对象来读取xml文件，获取Document对象 // 第二步，通过Document 对象，得到XML的根元素对象 // 第三步，通过根元素对象，获取所有的book标签对象 // 第四小，遍历每个book 标签对象。然后获取到book标签对象内的每一个元素，再通过getText() 方法拿到起始标签和结束标签之间的文本内容；也可以直接使用elementText()方法直接获取标签中的内容。 // 第一步，通过创建SAXReader 对象。来读取xml 文件，获取Document 对象 SAXReader reader = new SAXReader(); Document document = reader.read(\u0026quot;src/books.xml\u0026quot;); // 第二步，通过Document 对象。拿到XML 的根元素对象 Element root = document.getRootElement(); // 打印测试 // Element.asXML() 它将当前元素转换成为String 对象 // System.out.println( root.asXML() );//通过快捷键sout+enter自动生成打印语句 // 第三步，通过根元素对象。获取所有的book 标签对象 // Element.elements(标签名)它可以拿到当前元素下的指定的子元素的集合 List\u0026lt;Element\u0026gt; books = root.elements(\u0026quot;book\u0026quot;); // 第四步，遍历每个book 标签对象，然后获取到book 标签对象内的每一个元素， for (Element book : books) { // 测试 // System.out.println(book.asXML()); // 拿到book 下面的name 元素对象 Element nameElement = book.element(\u0026quot;name\u0026quot;); // 拿到book 下面的price 元素对象 Element priceElement = book.element(\u0026quot;price\u0026quot;); // 拿到book 下面的author 元素对象 Element authorElement = book.element(\u0026quot;author\u0026quot;); // 再通过getText() 方法拿到起始标签和结束标签之间的文本内容 System.out.println(\u0026quot;书名：\u0026quot; + nameElement.getText() + \u0026quot;, 价格:\u0026quot; + priceElement.getText() + \u0026quot;, 作者：\u0026quot; + authorElement.getText()); } }  运行结果为：\n书名:辟邪剑谱, 价格:9.9, 作者：班主任 书名:葵花宝典, 价格:99.99, 作者：班长\n","id":0,"section":"posts","summary":"一、XML简介 什么是XML xml 是可扩展的标记性语言。 XML的作用 用来保存数据，而且这些数据具有自我描述性； 它还可以作为项目或者模块的配置文件；","tags":null,"title":"XML","uri":"https://example.com/2020/07/xml/","year":"2020"},{"content":"jQuery [TOC]\njQuery介绍 什么是jQuery?——顾名思义，就是JavaScript和查询Qurey，它就是辅助JavaScript开发的js类库。\njQuery的核心思想是什么？——是write less,do more(写的更少，做的更多)，所以它实现了很多浏览器的兼容问题。\njQuery的流行程度——现在已经成为最流行的JavaScript库，在世界前10000个访问最多的网站中，有超过55%在使用jQuery。\njQuery的好处——是免费的，开源的，jQuery的语法设计可以使开发更加便捷，例如操作文档对象、选择DOM元素、制作动画效果、事件处理、使用Ajax以及其他功能。\n文档就绪事件 所有的jQuery函数都位于一个document ready函数中：\n$(document).ready(function(){ // 开始写 jQuery 代码... });  这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。\n如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：\n 试图隐藏一个不存在的元素 获得未完全加载的图像的大小  **提示：**简洁写法（与以上写法效果相同）:\n$(function(){ // 开始写 jQuery 代码... });  与JavaScript的入口函数（window.onload事件）的区别为：\n jQuery 的入口函数是只需要在html上 所有标签(DOM)都加载之后，就会去执行；可以执行多次，第N次也不是被上一次覆盖。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行；只能执行一次，如果第二次，那么第一次的执行会被覆盖。  window.onload = function () { // 开始写JavaScript代码 }  jQuery的HelloWorld程序 \u0026lt;!DOCTYPE html PUBLIC \u0026quot;-//W3C//DTD HTML 4.01 Transitional//EN\u0026quot; \u0026quot;http://www.w3.org/TR/html4/loose.dtd\u0026quot;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Insert title here\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;../script/jquery-1.7.2.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; $(function () { //表示页面加载完成之后，相当于window.onload = function () {} var $btnObj = $(\u0026quot;#btnId\u0026quot;);//表示按照id查询标签对象,jQuery对象默认以一个$打头 $btnObj.click(function () { //绑定单机事件 alert(\u0026quot;jQuery的单机事件\u0026quot;); }); }); // window.onload = function () { // var btnObj = document.getElementById(\u0026quot;btnId\u0026quot;); // btnObj.onclick = function () { // alert(\u0026quot;JS原生的点击事件\u0026quot;); // } // } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026quot;btnId\u0026quot;\u0026gt;SayHello\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  常见问题？\n  使用jQuery 一定要引入jQuery 库吗？ 答案： 是，必须。\n有两种jQuery库，其中一个为压缩版，如果访问外网，可以使用jquery-1.7.2.min.js，速度会快一些，常用于实际的网站中。一般情况下使用jquery-1.7.2.js，未压缩，是可读的代码，常用于测试和开发。\n  jQuery 中的$到底是什么？ 答案： 它是一个函数。\n  怎么为按钮添加点击响应函数的？\n  答案：\n（1）使用jQuery 查询到标签对象\n（2）使用标签对象.click( function(){} );\njQuery的核心函数 $是jQuery 的核心函数，能完成jQuery 的很多功能。​$()就是调用$这个函数。\n 传入参数为[函数] 时： 表示页面加载完成之后。相当于window.onload = function(){}。 传入参数为[ HTML 字符串] 时： 会对我们创建这个html 标签对象 传入参数为[ 选择器字符串] 时： $(“#id 属性值”); id 选择器，根据id 查询标签对象 $(“标签名”); 标签名选择器，根据指定的标签名查询标签对象 $(“.class 属性值”); 类型选择器，可以根据class 属性查询标签对象 传入参数为[ DOM 对象] 时： 会把这个dom 对象转换为jQuery 对象  jQuery对象和DOM对象的区别   Dom 对象\nDOM 对象Alert 出来的效果是：[object HTML 标签名Element]\n   通过getElementById()查询出来的标签对象是Dom 对象 通过getElementsByName()查询出来的标签对象是Dom 对象 通过getElementsByTagName()查询出来的标签对象是Dom 对象 通过createElement() 方法创建的对象，是Dom 对象   jQuery 对象 jQuery 对象Alert 出来的效果是：[object Object]   通过JQuery 提供的API 创建的对象，是JQuery 对象 通过JQuery 包装的Dom 对象，也是JQuery 对象 通过JQuery 提供的API 查询到的对象，是JQuery 对象   jQuery对象的本质实则是：==dom 对象的数组+ jQuery 提供的一系列功能函数==。  jQuery对象和DOM对象互转 jQuery 对象不能使用DOM 对象的属性和方法；DOM 对象也不能使用jQuery 对象的属性和方法。\ndom 对象转化为jQuery 对象（重点）\n 先有DOM 对象 $( DOM 对象) 就可以转换成为jQuery 对象  jQuery 对象转为dom 对象（重点）\n 先有jQuery 对象 jQuery 对象[下标]取出相应的DOM 对象  jQurey选择器 基本选择器（重点） ==#ID 选择器：根据id 查找标签对象==\n实例：当用户点击按钮后，有 id=\u0026quot;test\u0026rdquo; 属性的元素将被隐藏：\n$(document).ready(function(){ $(\u0026quot;button\u0026quot;).click(function(){ $(\u0026quot;#test\u0026quot;).hide(); }); });  ==.class 选择器：根据class 查找标签对象==\n实例：当用户点击按钮后，有 id=\u0026quot;test\u0026rdquo; 属性的元素将被隐藏：：用户点击按钮后，所有带有 class=\u0026quot;test\u0026rdquo; 属性的元素都隐藏：\n$(document).ready(function(){ $(\u0026quot;button\u0026quot;).click(function(){ $(\u0026quot;.test\u0026quot;).hide(); }); });  ==元素选择器：根据标签名查找标签对象==\n实例：用户点击按钮后，所有 元素都隐藏：\n$(document).ready(function(){ $(\u0026quot;button\u0026quot;).click(function(){ $(\u0026quot;p\u0026quot;).hide(); }); });  ==*选择器：表示任意的，所有的元素==\nselector1，selector2 组合选择器：合并选择器1，选择器2 的结果并返回，用逗号隔开\n层级选择器   **ancestor descendant 后代选择器：**在给定的祖先元素下匹配所有的后代元素\n  **parent \u0026gt; child 子元素选择器：**在给定的父元素下匹配所有的子元素\n  **prev + next 相邻元素选择器：**匹配所有紧接在prev 元素后的next 元素\n  **prev ~ sibings 之后的兄弟元素选择器：**匹配prev 元素之后的所有siblings 元素\n  注意：+和~都是求prev同级的元素。\n过滤选择器   基本过滤器\n:first 获取第一个元素 :last 获取最后个元素 :not(selector) 去除所有与给定选择器匹配的元素 :even 匹配所有索引值为偶数的元素，从0 开始计数 :odd 匹配所有索引值为奇数的元素，从0 开始计数 :eq(index) 匹配一个给定索引值的元素 :gt(index) 匹配所有大于给定索引值的元素 :lt(index) 匹配所有小于给定索引值的元素 :header 匹配如h1, h2, h3 之类的标题元素 :animated 匹配所有正在执行动画效果的元素\n  内容过滤器\n:contains(text) 匹配包含给定文本的元素 :empty 匹配所有不包含子元素或者文本的空元素 :parent 匹配含有子元素或者文本的元素 :has(selector) 匹配含有选择器所匹配的元素的元素\n  属性过滤器\n[attribute] 匹配包含给定属性的元素。 [attribute=value] 匹配给定的属性是某个特定值的元素 [attribute!=value] 匹配所有不含有指定的属性，或者属性不等于特定值的元素。 [attribute^=value] 匹配给定的属性是以某些值开始的元素 [attribute$=value] 匹配给定的属性是以某些值结尾的元素 [attribute*=value] 匹配给定的属性是以包含某些值的元素 [attrSel1][attrSel2][attrSelN] 复合属性选择器，需要同时满足多个条件时使用。\n  表单过滤器\n:input 匹配所有input, textarea, select 和button 元素 :text 匹配所有文本输入框 :password 匹配所有的密码输入框 :radio 匹配所有的单选框 :checkbox 匹配所有的复选框 :submit 匹配所有提交按钮 :image 匹配所有img 标签 :reset 匹配所有重置按钮 :button 匹配所有input type=button 按钮 :file 匹配所有input type=file 文件上传 :hidden 匹配所有不可见元素display:none 或input type=hidden\n  表单对过滤器\n:enabled 匹配所有可用元素 :disabled 匹配所有不可用元素 :checked 匹配所有选中的单选，复选，和下拉列表中选中的option 标签对象 :selected 匹配所有选中的option\n//4.获取多选框，每个选中的value值 $(\u0026quot;#btn4\u0026quot;).click(function(){ // 获取全部选中的复选框标签对象 var $checkboies = $(\u0026quot;:checkbox:checked\u0026quot;); // 老式遍历 // for (var i = 0; i \u0026lt; $checkboies.length; i++){ // alert( $checkboies[i].value ); // } // each方法是jQuery对象提供用来遍历元素的方法 // 在遍历的function函数中，有一个this对象，这个this对象，就是当前遍历到的dom对象 $checkboies.each(function () { alert( this.value ); }); });    jQuery元素筛选    元素筛选方法 备注     eq() 获取给定索引的元素 功能跟:eq() 一样   first() 获取第一个元素 功能跟:first 一样   last() 获取最后一个元素 功能跟:last 一样   is(exp) 判断是否匹配给定的选择器，只要有一个匹配就返回，true    has(exp) 返回包含有匹配选择器的元素的元素 功能跟:has 一样   not(exp) 删除匹配选择器的元素 功能跟:not 一样   children(exp) 返回匹配给定选择器的子元素 功能跟parent\u0026gt;child 一样   find(exp) 返回匹配给定选择器的后代元素 功能跟ancestor descendant 一样   next() 返回当前元素的下一个兄弟元素 功能跟prev + next 功能一样   nextAll() 返回当前元素后面所有的兄弟元素 功能跟prev ~ siblings 功能一样   nextUntil() 返回当前元素到指定匹配的元素为止的后面元素    parent() 返回父元素    prev(exp) 返回当前元素的上一个兄弟元素    prevAll() 返回当前元素前面所有的兄弟元素    prevUnit(exp) 返回当前元素到指定匹配的元素为止的前面元素    siblings(exp) 返回所有兄弟元素    add() 把add 匹配的选择器的元素添加到当前jquery 对象中     jQuery的属性操作    属性操作 作用 备注     html() 它可以设置和获取起始标签和结束标签中的内容 跟dom属性innerHTML 一样   text() 它可以设置和获取起始标签和结束标签中的文本 跟dom属性innerText 一样   val() 它可以设置和获取表单项的value 属性值 跟dom属性value 一样    val 方法同时设置多个表单项的选中状态：\n$(function () { // 批量操作单选 $(\u0026quot;:radio\u0026quot;).val([\u0026quot;radio2\u0026quot;]); // 批量操作筛选框的选中状态 $(\u0026quot;:checkbox\u0026quot;).val([\u0026quot;checkbox3\u0026quot;,\u0026quot;checkbox2\u0026quot;]); // 批量操作多选的下拉框选中状态 $(\u0026quot;#multiple\u0026quot;).val([\u0026quot;mul2\u0026quot;,\u0026quot;mul3\u0026quot;,\u0026quot;mul4\u0026quot;]); // 操作单选的下拉框选中状态 $(\u0026quot;#single\u0026quot;).val([\u0026quot;sin2\u0026quot;]); $(\u0026quot;#multiple,#single,:radio,:checkbox\u0026quot;).val([\u0026quot;radio2\u0026quot;,\u0026quot;checkbox1\u0026quot;,\u0026quot;mul1\u0026quot;,\u0026quot;mul4\u0026quot;,\u0026quot;sin3\u0026quot;]); });  attr() 可以设置和获取属性的值，不推荐操作checked、readOnly、selected、disabled 等等 还可以操作非标准的属性。比如自定义属性：abc,bbj prop() 可以设置和获取属性的值，只推荐操作checked、readOnly、selected、disabled 等等\nDOM的增删改 内部插入： appendTo() ——a.appendTo(b) 把a 插入到b 子元素末尾，成为最后一个子元素 prependTo() ——a.prependTo(b) 把a 插到b 所有子元素前面，成为第一个子元素 外部插入： insertAfter() ——a.insertAfter(b) 得到ba insertBefore() ——a.insertBefore(b) 得到ab 替换: replaceWith() ——a.replaceWith(b) 用b 替换掉a replaceAll() ——a.replaceAll(b) 用a 替换掉所有b 删除： remove() ——a.remove(); 删除a 标签 empty() ——a.empty(); 清空a 标签里的内容\nCSS 样式操作 addClass() 添加样式 removeClass() 删除样式 toggleClass() 有就删除，没有就添加样式。 offset() 获取和设置元素的坐标。\njQuery 动画  基本动画 show() 将隐藏的元素显示 hide() 将可见的元素隐藏。 toggle() 可见就隐藏，不可见就显示。 以上动画方法都可以添加参数。 1、第一个参数是动画执行的时长，以毫秒为单位 2、第二个参数是动画的回调函数(动画完成后自动调用的函数) 淡入淡出动画 fadeIn() 淡入（慢慢可见） fadeOut() 淡出（慢慢消失） fadeTo() 在指定时长内慢慢的将透明度修改到指定的值。0 透明，1 完成可见，0.5 半透明 fadeToggle() 淡入/淡出切换  jQuery事件操作 注：此块内容与文档就绪事件部分的内容一致。\n他们分别是在什么时候触发？\n1、jQuery 的页面加载完成之后是浏览器的内核解析完页面的标签创建好DOM 对象之后就会马上执行。\n2、原生js 的页面加载完成之后，除了要等浏览器内核解析完标签创建好DOM 对象，还要等标签显示时需要的内容加载完成。\n他们触发的顺序？\n1、jQuery 页面加载完成之后先执行\n2、原生js 的页面加载完成之后\n他们执行的次数？\n1、原生js 的页面加载完成之后，只会执行最后一次的赋值函数。\n2、jQuery 的页面加载完成之后是全部把注册的function 函数，依次顺序全部执行。\njQuery 中其他的事件处理方法：\nclick() 它可以绑定单击事件，以及触发单击事件\nmouseover() 鼠标移入事件\nmouseout() 鼠标移出事件\nbind() 可以给元素一次性绑定一个或多个事件\none() 使用上跟bind 一样。但是one 方法绑定的事件只会响应一次\nunbind() 跟bind 方法相反的操作，解除事件的绑定\nlive() 也是用来绑定事件。它可以用来绑定选择器匹配的所有元素的事件，哪怕这个元素是后面动态创建出\n来的也有效\n事件的冒泡 什么是事件的冒泡？\n事件的冒泡是指，父子元素同时监听同一个事件。当触发子元素的事件的时候，同一个事件也被传递到了父元素的事件里去响应。\n那么如何阻止事件冒泡呢？\n在子元素事件函数体内，return false; 可以阻止事件的冒泡传递。\nJavaScript事件对象 事件对象，是封装有触发的事件信息的一个javascript 对象。\n我们重点关心的是怎么拿到这个javascript 的事件对象以及使用。\n如何获取javascript 事件对象呢？\n在给元素绑定事件的时候，在事件的function( event ) 参数列表中添加一个参数，这个参数名，我们习惯取名为event。这个event 就是javascript 传递参事件处理函数的事件对象。\n","id":1,"section":"posts","summary":"jQuery [TOC] jQuery介绍 什么是jQuery?——顾名思义，就是JavaScript和查询Qurey，它就是辅助JavaScript开发的js类库","tags":null,"title":"JQuery","uri":"https://example.com/2020/07/jquery/","year":"2020"},{"content":"JavaScript [TOC]\nJS介绍  JS是弱类型，即类型可变； Java是强类型，即定义变量时，类型已确定，而且不可变。  JS的特点：\n  交互性（它可以做的就是信息的动态交互）\n  安全性（不允许直接访问本地硬盘）\n  跨平台性（只要是可以解释JS 的浏览器都可以执行，和平台无关）\n  JavaScript 和html 代码的结合方式：\n 只需要在head 标签中，或者在body 标签中， 使用script 标签来书写JavaScript 代码； 使用script 标签通过src属性引入单独的JavaScript 代码文件。   变量  JavaScript 的变量类型：   数值类型： number 字符串类型： string 对象类型： object 布尔类型： boolean 函数类型： function  JavaScript 里特殊的值    undefined 未定义，所有js 变量未赋于初始值的时候，默认值都是undefined；\n  null 空值；\n  NaN 全称是：Not a Number。非数字，非数值。\n   变量的定义方式\n var 变量名; var 变量名= 值;\n   关系（比较）运算  等于： == 等于是简单的做字面值的比较 全等于： === 除了做字面值的比较之外，还会比较两个变量的数据类型  逻辑运算  且运算： \u0026amp;\u0026amp;  第一种：当表达式全为真的时候，返回最后一个表达式的值； 第二种：当表达式中，有一个为假的时候。返回第一个为假的表达式的值。   或运算： ||  第一种情况：当表达式全为假时，返回最后一个表达式的值； 第二种情况：只要有一个表达式为真。就会把第一个为真的表达式的值。   取反运算： ! 在JavaScript 语言中，所有的变量，都可以做为一个boolean 类型的变量去使用。 0 、null、undefined、””(空串，没有空格) 都认为是false  数组   数组的定义格式\n var 数组名= []; // 空数组 var 数组名= [1 , ’abc’ , true]; // 定义数组同时赋值元素\n   javaScript语言中的数组，只要我们通过数组下标赋值，那么最大的下标值，就会自动的给数组做扩容操作。\n  函数  第一种，可以使用function 关键字来定义函数。  function 函数名(形参列表) { 函数体 }  在JavaScript 语言中，如何定义带有返回值的函数？ 只需要在函数体内直接使用return 语句返回值即可！\n  第二种\n var 函数名= function(形参列表) { 函数体}\n   JS不允许重载 在Java 中函数允许重载。但是在JS 中函数的重载会直接覆盖掉上一次的定义\n函数的arguments 隐形参数（只在function 函数内） 就是在function 函数中不需要定义，但却可以直接用来获取所有参数的变量。我们管它叫隐形参数。隐形参数特别像java 基础的可变长参数一样。\npublic void fun( Object ... args );  可变长参数其他是一个数组。那么js 中的隐形参数也跟java 的可变长参数一样。操作类似数组。\nJS 中的自定义对象 1. Object 形式的自定义对象  对象的定义：  var 变量名= new Object(); // 对象实例（空对象） 变量名.属性名= 值; // 定义一个属性 变量名.函数名= function(){} // 定义一个函数   对象的访问：  变量名.属性/ 函数名();  2. {}花括号形式的自定义对象  对象的定义：  var 变量名= { // 空对象 属性名：值, // 定义一个属性 属性名：值, // 定义一个属性 函数名：function(){} // 定义一个函数 };   对象的访问：  变量名.属性/ 函数名();\t JS中的事件 事件是电脑输入设备与页面进行交互的响应。\n常用的事件：\n  onload 加载完成事件： 页面加载完成之后，常用于做页面js 代码初始化操作。\n  onclick 单击事件： 常用于按钮的点击响应操作。\n  onblur 失去焦点事件： 常用于输入框失去焦点后验证其输入内容是否合法。\n  onchange 内容发生改变事件： 常用于下拉列表和输入框内容发生改变后操作。\n  onsubmit 表单提交事件： 常用于表单提交前，验证所有表单项是否合法。\n  事件的注册（绑定）:是告诉浏览器，当事件响应后要执行哪些操作代码。\n 静态注册事件：通过html 标签的事件属性直接赋于事件响应后的代码，这种方式我们叫静态注册。 动态注册事件：是指先通过js 代码得到标签的dom对象，然后再通过dom 对象.事件名= function(){} 这种形式赋于事件响应后的代码，叫动态注册。 动态注册基本步骤： 1、获取标签对象 2、标签对象.事件名= fucntion(){}  1. onload加载完成事件:浏览器解析完页面之后就会自动触发的事件。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; // onload事件的方法 function onloadFun() { alert('静态注册onload事件，所有代码'); } // onload事件动态注册。是固定写法 window.onload = function () { alert(\u0026quot;动态注册的onload事件\u0026quot;); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;!--静态注册onload事件 onload事件是浏览器解析完页面之后就会自动触发的事件 \u0026lt;body onload=\u0026quot;onloadFun();\u0026quot;\u0026gt; --\u0026gt; \u0026lt;body onload=\u0026quot;onloadFun();\u0026quot;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  2. onclick单击事件： 常用于按钮的点击响应操作。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function onclickFun() { alert(\u0026quot;静态注册onclick事件\u0026quot;); } // 动态注册onclick事件 window.onload = function () { // 1 获取标签对象 /* * document 是JavaScript语言提供的一个对象（文档） * getElementById通过id属性获取标签对象 **/ var btnObj = document.getElementById(\u0026quot;btn01\u0026quot;); // alert( btnObj ); // 2 通过标签对象.事件名 = function(){} btnObj.onclick = function () { alert(\u0026quot;动态注册的onclick事件\u0026quot;); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--静态注册onClick事件--\u0026gt; \u0026lt;button onclick=\u0026quot;onclickFun();\u0026quot;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026quot;btn01\u0026quot;\u0026gt;按钮2\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  3. onblur失去焦点事件： 常用于输入框失去焦点后验证其输入内容是否合法。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; // 静态注册失去焦点事件 function onblurFun() { // console是控制台对象，是由JavaScript语言提供，专门用来向浏览器的控制台打印输出， 用于测试使用 // log() 是打印的方法 //alert 与失去焦点容易起冲突 console.log(\u0026quot;静态注册失去焦点事件\u0026quot;); } // 动态注册 onblur事件 window.onload = function () { //1 获取标签对象 var passwordObj = document.getElementById(\u0026quot;password\u0026quot;); // alert(passwordObj); //2 通过标签对象.事件名 = function(){}; passwordObj.onblur = function () { console.log(\u0026quot;动态注册失去焦点事件\u0026quot;); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 用户名:\u0026lt;input type=\u0026quot;text\u0026quot; onblur=\u0026quot;onblurFun();\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; 密码:\u0026lt;input id=\u0026quot;password\u0026quot; type=\u0026quot;text\u0026quot; \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  4. onchange内容发生改变事件：常用于下拉列表和输入框内容发生改变后操作。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function onchangeFun() { alert(\u0026quot;女神已经改变了\u0026quot;); } window.onload = function () { //1 获取标签对象 var selObj = document.getElementById(\u0026quot;sel01\u0026quot;); // alert( selObj ); //2 通过标签对象.事件名 = function(){} selObj.onchange = function () { alert(\u0026quot;男神已经改变了\u0026quot;); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 请选择你心中的女神： \u0026lt;!--静态注册onchange事件--\u0026gt; \u0026lt;select onchange=\u0026quot;onchangeFun();\u0026quot;\u0026gt; \u0026lt;option\u0026gt;--女神--\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;芳芳\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;佳佳\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;娘娘\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 请选择你心中的男神： \u0026lt;select id=\u0026quot;sel01\u0026quot;\u0026gt; \u0026lt;option\u0026gt;--男神--\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;国哥\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;华仔\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;富城\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  5. onsubmit 表单提交事件： 常用于表单提交前，验证所有表单项是否合法。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; \u0026gt; // 静态注册表单提交事务 function onsubmitFun(){ // 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交 alert(\u0026quot;静态注册表单提交事件----发现不合法\u0026quot;); return false; } window.onload = function () { //1 获取标签对象 var formObj = document.getElementById(\u0026quot;form01\u0026quot;); //2 通过标签对象.事件名 = function(){} formObj.onsubmit = function () { // 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交 alert(\u0026quot;动态注册表单提交事件----发现不合法\u0026quot;); return false; } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--return false 可以阻止 表单提交 --\u0026gt; \u0026lt;form action=\u0026quot;http://localhost:8080\u0026quot; method=\u0026quot;get\u0026quot; onsubmit=\u0026quot;return onsubmitFun();\u0026quot;\u0026gt;//注意：一定要写return \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;静态注册\u0026quot;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;form action=\u0026quot;http://localhost:8080\u0026quot; id=\u0026quot;form01\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;动态注册\u0026quot;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  DOM模型 DOM全称是Document Object Model 文档对象模型，就是把文档中的标签，属性，文本，转换成为对象来管理。\nDocument对象 Document 对象的理解： 第一点：Document 它管理了所有的HTML 文档内容。 第二点：document 它是一种树结构的文档，有层级关系。 第三点：它让我们把所有的标签都对象化。 第四点：我们可以通过document 访问所有的标签对象。 那么html 标签要对象化怎么办？\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026quot;div01\u0026quot;\u0026gt;div01\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;  模拟对象化，相当于：\nclass Dom{ private String id; // id 属性 private String tagName; //表示标签名 private Dom parentNode; //父亲 private List\u0026lt;Dom\u0026gt; children; // 孩子结点 private String innerHTML; // 起始标签和结束标签中间的内容 }  Document 对象中的方法介绍  document.getElementById(elementId) 通过标签的id 属性查找标签dom 对象，elementId 是标签的id 属性值 document.getElementsByName(elementName) 通过标签的name 属性查找标签dom 对象，elementName 标签的name 属性值 document.getElementsByTagName(tagname) 通过标签名查找标签dom 对象。tagname 是标签名 document.createElement( tagName) 方法，通过给定的标签名，创建一个标签对象。tagName 是要创建的标签名  注意：document 对象的三个查询方法，如果有id 属性，优先使用getElementById 方法来进行查询；如果没有id 属性，则优先使用getElementsByName 方法来进行查询；如果id 属性和name 属性都没有最后再按标签名查getElementsByTagName。\n以上三个方法，一定要在页面加载完成之后执行，才能查询到标签对象。\n节点的常用属性和方法 节点就是标签对象\n  方法 通过具体的元素节点调用 getElementsByTagName()方法，获取当前节点的指定标签名孩子节点； appendChild( oChildNode )方法，可以添加一个子节点，oChildNode 是要添加的孩子节点\n  属性 childNodes属性，获取当前节点的所有子节点； firstChild属性，获取当前节点的第一个子节点； lastChild属性，获取当前节点的最后一个子节点； parentNode属性，获取当前节点的父节点； nextSibling属性，获取当前节点的下一个节点； previousSibling属性，获取当前节点的上一个节点； className用于获取或设置标签的class 属性值； innerHTML属性，表示获取/设置起始标签和结束标签中的内容； innerText属性，表示获取/设置起始标签和结束标签中的文本。\n  ","id":2,"section":"posts","summary":"JavaScript [TOC] JS介绍 JS是弱类型，即类型可变； Java是强类型，即定义变量时，类型已确定，而且不可变。 JS的特点： 交互性（它可以做的就是信息的动态交","tags":null,"title":"JavaScript","uri":"https://example.com/2020/07/js%E5%9F%BA%E7%A1%80/","year":"2020"}],"tags":[]}